1. ##### 一个是线程同步的，基本就是如何确保临界区，最多只有三个线程进入
	

通过**semaphore**可以控制并发的数量
	Semaphore semaphore = new semaphore(int permits);
	semaphore.acquire();
	deal();
	semaphore.release();


​	**permits**代表同时允许进入同步区的线程数量，通过**accquire()**方法获取信号量，**release()**方法释放信号量
​	

2. ##### 四五个类的继承链问重写方法的调用


如果子类重写了父类中的方法，则优先调用自身的方法，否则调用父类的方法
   	
当某个类A同时继承了父类、实现了接口，父类与接口中存在相同的方法定义，创建A对象时并向上转型后调用该方法时，优先调用A中的方法逻辑，其次是父类中的方法逻辑
   	
3. ##### 对静态内部类.class调用toString方法
   

外部类：**Entry**
内部类：**Inner**

在外部类中调用println方法进行输出：
`System.out.println(Inner.class.toString())`
class org.hr.testDemo.extend.multi.Entry$Inner
   	

4. ##### Top K问题

	1. 如果是KV类型的数据，先根据K进行分组
	2. 在分组后的数据中将结果进行reduce
	3. 根据K进行降序排序，并取前K的数据

	------
	
	1. 如果是K类型的数据，则先调用map方法将数据转化为KV类型的数据
	2. 根据K进行分组
   3. 在分组后的数据中将结果进行reduce
   4. 根据K进行降序排序，并取前K的数据
   
5. ##### 把数组中的重复元素去掉然后按升序排序

   1. 通过List进行去重，再排序
   2. 创建目标数组，对原数组进行双重循环判断重复元素，再排序

6. ##### 一致性哈希算法

  - 目的：将数据进行更加均匀的映射，主要用于缓存
  - 实现步骤
    - 取出数据的hashCode，并将其对2^32取余获得值：A
    - 将0到2^32-1区间想象为一个闭合的环，将缓存节点均匀分布在这个环上
    - 将A值放在该环上，顺时针遇到的第一个节点即为数据缓存的目标节点
    - 当缓存节点比较少的时候，可以虚拟出多个虚拟节点，提高数据的均匀分布性

7. ##### CountDownLatch

   > CountDownLatch为一个线程等待工具，主要的目的是控制线程执行的次数，并让主线程等待其他线程结束后再继续
   >
   > 使用创建CountDownLatch对象时可以传入一个int值，在线程进行具体的业务操作时，可以调用CountDownLatch.count()方法降低值，在线程外部调用await()方法阻断主线程的继续，

8. ##### 阻塞队列

9. ##### 线程池 

   > 线程池是一个池化技术，线程是一个创建代价昂贵的资源，所以需要将线程进行统一管理，提高线程资源的利用效率、系统的反应速度(获取线程的速度)
   >
   > 核心参数：
   >
   > 1. 核心线程数量
   > 2. 最大线程数量
   > 3. 线程活跃时间
   > 4. 等待队列
   > 5. 等待队列满了并且线程数量达到最大线程数量时对于任务的拒绝策略

10. ##### Spring的事务传播行为

11. ##### AOP

12. ##### AQS

13. ##### 分布式锁

14. ##### 手写算法题统计连续子数组和等于指定值的次数

15. ##### java List，HashMap的操作

16. ##### B树遍历比二叉树快还是慢

17. ##### 为什么ORACLE默认使用BTREE的存储结构

答BTREE适用于早起计算机内存不大的时候，可以当做整个文件读进内存进行读写操作。

18. ##### 堆排序